{
  "ret": "When the ‘ret’ instruction is executed, control flow returns back to the calling function’s context. If the caller is a “call” instruction, execution continues at the instruction after the call. If the caller was an “invoke” instruction, execution continues at the beginning of the “normal” destination block. If the instruction returns a value, that value shall set the call or invoke instruction’s return value.",
  "br": "Upon execution of a conditional ‘br’ instruction, the ‘i1’ argument is evaluated. If the value is true, control flows to the ‘iftrue’ label argument. If “cond” is false, control flows to the ‘iffalse’ label argument. If ‘cond’ is poison or undef, this instruction has undefined behavior.",
  "switch": "The switch instruction specifies a table of values and destinations. When the ‘switch’ instruction is executed, this table is searched for the given value. If the value is found, control flow is transferred to the corresponding destination; otherwise, control flow is transferred to the default destination. If ‘value’ is poison or undef, this instruction has undefined behavior.",
  "indirectbr": "Control transfers to the block specified in the address argument. All possible destination blocks must be listed in the label list, otherwise this instruction has undefined behavior. This implies that jumps to labels defined in other functions have undefined behavior as well. If ‘address’ is poison or undef, this instruction has undefined behavior.",
  "invoke": "This instruction is designed to operate as a standard ‘call’ instruction in most regards. The primary difference is that it establishes an association with a label, which is used by the runtime library to unwind the stack. This instruction is used in languages with destructors to ensure that proper cleanup is performed in the case of either a longjmp or a thrown exception. Additionally, this is important for implementation of ‘catch’ clauses in high-level languages that support them. For the purposes of the SSA form, the definition of the value returned by the ‘invoke’ instruction is deemed to occur on the edge from the current block to the “normal” label. If the callee unwinds then no return value is available.",
  "callbr": "This instruction is designed to operate as a standard ‘call’ instruction in most regards. The primary difference is that it establishes an association with additional labels to define where control flow goes after the call. The output values of a ‘callbr’ instruction are available both in the the ‘fallthrough’ block, and any ‘indirect’ blocks(s). The only use of this today is to implement the “goto” feature of gcc inline assembly where additional labels can be provided as locations for the inline assembly to jump to.",
  "resume": "The ‘resume’ instruction resumes propagation of an existing (in-flight) exception whose unwinding was interrupted with a landingpad instruction.",
  "catchswitch": "Executing this instruction transfers control to one of the successors in handlers, if appropriate, or continues to unwind via the unwind label if present. The catchswitch is both a terminator and a “pad” instruction, meaning that it must be both the first non-phi instruction and last instruction in the basic block. Therefore, it must be the only non-phi instruction in the block.",
  "catchret": "The ‘catchret’ instruction ends an existing (in-flight) exception whose unwinding was interrupted with a catchpad instruction. The personality function gets a chance to execute arbitrary code to, for example, destroy the active exception. Control then transfers to normal. The token argument must be a token produced by a catchpad instruction. If the specified catchpad is not the most-recently-entered not-yet-exited funclet pad (as described in the EH documentation), the catchret’s behavior is undefined.",
  "cleanupret": "The ‘cleanupret’ instruction indicates to the personality function that one cleanuppad it transferred control to has ended. It transfers control to continue or unwinds out of the function.",
  "unreachable": "The ‘unreachable’ instruction has no defined semantics. This instruction is used to inform the optimizer that a particular portion of the code is not reachable. This can be used to indicate that the code after a no-return function cannot be reached, and other facts.",
  "fneg": "The value produced is a copy of the operand with its sign bit flipped. The value is otherwise completely identical; in particular, if the input is a NaN, then the quiet/signaling bit and payload are perfectly preserved. This instruction can also take any number of fast-math flags, which are optimization hints to enable otherwise unsafe floating-point optimizations.",
  "add": "The value produced is the integer sum of the two operands. If the sum has unsigned overflow, the result returned is the mathematical result modulo 2n, where n is the bit width of the result. Because LLVM integers use a two’s complement representation, this instruction is appropriate for both signed and unsigned integers. nuw and nsw stand for “No Unsigned Wrap” and “No Signed Wrap”, respectively. If the nuw and/or nsw keywords are present, the result value of the add is a poison value if unsigned and/or signed overflow, respectively, occurs.",
  "fadd": "The value produced is the floating-point sum of the two operands. This instruction is assumed to execute in the default floating-point environment. This instruction can also take any number of fast-math flags, which are optimization hints to enable otherwise unsafe floating-point optimizations.",
  "sub": "The value produced is the integer difference of the two operands. If the difference has unsigned overflow, the result returned is the mathematical result modulo 2n, where n is the bit width of the result. Because LLVM integers use a two’s complement representation, this instruction is appropriate for both signed and unsigned integers. nuw and nsw stand for “No Unsigned Wrap” and “No Signed Wrap”, respectively. If the nuw and/or nsw keywords are present, the result value of the sub is a poison value if unsigned and/or signed overflow, respectively, occurs.",
  "fsub": "The value produced is the floating-point difference of the two operands. This instruction is assumed to execute in the default floating-point environment. This instruction can also take any number of fast-math flags, which are optimization hints to enable otherwise unsafe floating-point optimizations.",
  "mul": "The value produced is the integer product of the two operands. If the result of the multiplication has unsigned overflow, the result returned is the mathematical result modulo 2n, where n is the bit width of the result. Because LLVM integers use a two’s complement representation, and the result is the same width as the operands, this instruction returns the correct result for both signed and unsigned integers. If a full product (e.g. i32 * i32 -> i64) is needed, the operands should be sign-extended or zero-extended as appropriate to the width of the full product. nuw and nsw stand for “No Unsigned Wrap” and “No Signed Wrap”, respectively. If the nuw and/or nsw keywords are present, the result value of the mul is a poison value if unsigned and/or signed overflow, respectively, occurs.",
  "fmul": "The value produced is the floating-point product of the two operands. This instruction is assumed to execute in the default floating-point environment. This instruction can also take any number of fast-math flags, which are optimization hints to enable otherwise unsafe floating-point optimizations.",
  "udiv": "The value produced is the unsigned integer quotient of the two operands. Note that unsigned integer division and signed integer division are distinct operations; for signed integer division, use ‘sdiv’. Division by zero is undefined behavior. For vectors, if any element of the divisor is zero, the operation has undefined behavior. If the exact keyword is present, the result value of the udiv is a poison value if %op1 is not a multiple of %op2 (as such, “((a udiv exact b) mul b) == a”).",
  "sdiv": "The value produced is the signed integer quotient of the two operands rounded towards zero. Note that signed integer division and unsigned integer division are distinct operations; for unsigned integer division, use ‘udiv’. Division by zero is undefined behavior. For vectors, if any element of the divisor is zero, the operation has undefined behavior. Overflow also leads to undefined behavior; this is a rare case, but can occur, for example, by doing a 32-bit division of -2147483648 by -1. If the exact keyword is present, the result value of the sdiv is a poison value if the result would be rounded.",
  "fdiv": "The value produced is the floating-point quotient of the two operands. This instruction is assumed to execute in the default floating-point environment. This instruction can also take any number of fast-math flags, which are optimization hints to enable otherwise unsafe floating-point optimizations.",
  "urem": "This instruction returns the unsigned integer remainder of a division. This instruction always performs an unsigned division to get the remainder. Note that unsigned integer remainder and signed integer remainder are distinct operations; for signed integer remainder, use ‘srem’. Taking the remainder of a division by zero is undefined behavior. For vectors, if any element of the divisor is zero, the operation has undefined behavior.",
  "srem": "This instruction returns the remainder of a division (where the result is either zero or has the same sign as the dividend, op1), not the modulo operator (where the result is either zero or has the same sign as the divisor, op2) of a value. For more information about the difference, see The Math Forum. For a table of how this is implemented in various languages, please see Wikipedia: modulo operation. Note that signed integer remainder and unsigned integer remainder are distinct operations; for unsigned integer remainder, use ‘urem’. Taking the remainder of a division by zero is undefined behavior. For vectors, if any element of the divisor is zero, the operation has undefined behavior. Overflow also leads to undefined behavior; this is a rare case, but can occur, for example, by taking the remainder of a 32-bit division of -2147483648 by -1. (The remainder doesn’t actually overflow, but this rule lets srem be implemented using instructions that return both the result of the division and the remainder.).",
  "frem": "The value produced is the floating-point remainder of the two operands. This is the same output as a libm ‘fmod’ function, but without any possibility of setting errno. The remainder has the same sign as the dividend. This instruction is assumed to execute in the default floating-point environment. This instruction can also take any number of fast-math flags, which are optimization hints to enable otherwise unsafe floating-point optimizations.",
  "shl": "The value produced is op1 * 2op2 mod 2n, where n is the width of the result. If op2 is (statically or dynamically) equal to or larger than the number of bits in op1, this instruction returns a poison value. If the arguments are vectors, each vector element of op1 is shifted by the corresponding shift amount in op2. If the nuw keyword is present, then the shift produces a poison value if it shifts out any non-zero bits. If the nsw keyword is present, then the shift produces a poison value if it shifts out any bits that disagree with the resultant sign bit.",
  "lshr": "This instruction always performs a logical shift right operation. The most significant bits of the result will be filled with zero bits after the shift. If op2 is (statically or dynamically) equal to or larger than the number of bits in op1, this instruction returns a poison value. If the arguments are vectors, each vector element of op1 is shifted by the corresponding shift amount in op2. If the exact keyword is present, the result value of the lshr is a poison value if any of the bits shifted out are non-zero.",
  "ashr": "This instruction always performs an arithmetic shift right operation, The most significant bits of the result will be filled with the sign bit of op1. If op2 is (statically or dynamically) equal to or larger than the number of bits in op1, this instruction returns a poison value. If the arguments are vectors, each vector element of op1 is shifted by the corresponding shift amount in op2. If the exact keyword is present, the result value of the ashr is a poison value if any of the bits shifted out are non-zero.",
  "and": "The ‘and’ instruction returns the bitwise logical and of its two operands.",
  "or": "The ‘or’ instruction returns the bitwise logical inclusive or of its two operands.",
  "xor": "The ‘xor’ instruction returns the bitwise logical exclusive or of its two operands. The xor is used to implement the “one’s complement” operation, which is the “~” operator in C.",
  "extractelement": "The result is a scalar of the same type as the element type of val. Its value is the value at position idx of val. If idx exceeds the length of val for a fixed-length vector, the result is a poison value. For a scalable vector, if the value of idx exceeds the runtime length of the vector, the result is a poison value.",
  "insertelement": "The result is a vector of the same type as val. Its element values are those of val except at position idx, where it gets the value elt. If idx exceeds the length of val for a fixed-length vector, the result is a poison value. For a scalable vector, if the value of idx exceeds the runtime length of the vector, the result is a poison value.",
  "shufflevector": "The elements of the two input vectors are numbered from left to right across both of the vectors. For each element of the result vector, the shuffle mask selects an element from one of the input vectors to copy to the result. Non-negative elements in the mask represent an index into the concatenated pair of input vectors. A poison element in the mask vector specifies that the resulting element is poison. For backwards-compatibility reasons, LLVM temporarily also accepts undef mask elements, which will be interpreted the same way as poison elements. If the shuffle mask selects an undef element from one of the input vectors, the resulting element is undef. For scalable vectors, the only valid mask values at present are zeroinitializer, undef and poison, since we cannot write all indices as literals for a vector with a length unknown at compile time.",
  "extractvalue": "The result is the value at the position in the aggregate specified by the index operands.",
  "insertvalue": "The result is an aggregate of the same type as val. Its value is that of val except that the value at the position specified by the indices is that of elt.",
  "alloca": "Memory is allocated; a pointer is returned. The allocated memory is uninitialized, and loading from uninitialized memory produces an undefined value. The operation itself is undefined if there is insufficient stack space for the allocation.’alloca’d memory is automatically released when the function returns. The ‘alloca’ instruction is commonly used to represent automatic variables that must have an address available. When the function returns (either with the ret or resume instructions), the memory is reclaimed. Allocating zero bytes is legal, but the returned pointer may not be unique. The order in which memory is allocated (ie., which way the stack grows) is not specified. Note that ‘alloca’ outside of the alloca address space from the datalayout string is meaningful only if the target has assigned it a semantics. For targets that specify a non-zero alloca address space in the datalayout string, the alloca address space needs to be explicitly specified in the instruction if it is to be used. If the returned pointer is used by llvm.lifetime.start, the returned object is initially dead. See llvm.lifetime.start and llvm.lifetime.end for the precise semantics of lifetime-manipulating intrinsics.",
  "load": "The location of memory pointed to is loaded. If the value being loaded is of scalar type then the number of bytes read does not exceed the minimum number of bytes needed to hold all bits of the type. For example, loading an i24 reads at most three bytes. When loading a value of a type like i20 with a size that is not an integral number of bytes, the result is undefined if the value was not originally written using a store of the same type. If the value being loaded is of aggregate type, the bytes that correspond to padding may be accessed but are ignored, because it is impossible to observe padding from the loaded aggregate value. If <pointer> is not a well-defined value, the behavior is undefined.",
  "store": "The contents of memory are updated to contain <value> at the location specified by the <pointer> operand. If <value> is of scalar type then the number of bytes written does not exceed the minimum number of bytes needed to hold all bits of the type. For example, storing an i24 writes at most three bytes. When writing a value of a type like i20 with a size that is not an integral number of bytes, it is unspecified what happens to the extra bits that do not belong to the type, but they will typically be overwritten. If <value> is of aggregate type, padding is filled with undef. If <pointer> is not a well-defined value, the behavior is undefined.",
  "fence": "A fence A which has (at least) release ordering semantics synchronizes with a fence B with (at least) acquire ordering semantics if and only if there exist atomic operations X and Y, both operating on some atomic object M, such that A is sequenced before X, X modifies M (either directly or through some side effect of a sequence headed by X), Y is sequenced before B, and Y observes M. This provides a happens-before dependency between A and B. Rather than an explicit fence, one (but not both) of the atomic operations X or Y might provide a release or acquire (resp.) ordering constraint and still synchronize-with the explicit fence and establish the happens-before edge. A fence which has seq_cst ordering, in addition to having both acquire and release semantics specified above, participates in the global program order of other seq_cst operations and/or fences. Furthermore, the global ordering created by a seq_cst fence must be compatible with the individual total orders of monotonic (or stronger) memory accesses occurring before and after such a fence. The exact semantics of this interaction are somewhat complicated, see the C++ standard’s [atomics.order] section for more details. A fence instruction can also take an optional “syncscope” argument.",
  "cmpxchg": "The contents of memory at the location specified by the ‘<pointer>’ operand is read and compared to ‘<cmp>’; if the values are equal, ‘<new>’ is written to the location. The original value at the location is returned, together with a flag indicating success (true) or failure (false). If the cmpxchg operation is marked as weak then a spurious failure is permitted: the operation may not write <new> even if the comparison matched. If the cmpxchg operation is strong (the default), the i1 value is 1 if and only if the value loaded equals cmp. A successful cmpxchg is a read-modify-write instruction for the purpose of identifying release sequences. A failed cmpxchg is equivalent to an atomic load with an ordering parameter determined the second ordering parameter.",
  "automicrmw": "The ‘atomicrmw’ instruction is used to atomically modify memory.",
  "getelementptr": "The ‘getelementptr’ instruction is used to get the address of a subelement of an aggregate data structure. It performs address calculation only and does not access memory. The instruction can also be used to calculate a vector of such addresses.",
  "trunc": "The ‘trunc’ instruction truncates the high order bits in value and converts the remaining bits to ty2. Since the source size must be larger than the destination size, trunc cannot be a no-op cast. It will always truncate bits. If the nuw keyword is present, and any of the truncated bits are non-zero, the result is a poison value. If the nsw keyword is present, and any of the truncated bits are not the same as the top bit of the truncation result, the result is a poison value.",
  "zext": "The zext fills the high order bits of the value with zero bits until it reaches the size of the destination type, ty2. When zero extending from i1, the result will always be either 0 or 1. If the nneg flag is set, and the zext argument is negative, the result is a poison value.",
  "sext": "The ‘sext’ instruction performs a sign extension by copying the sign bit (highest order bit) of the value until it reaches the bit size of the type ty2. When sign extending from i1, the extension always results in -1 or 0.",
  "fptrunc": "The ‘fptrunc’ instruction truncates value to type ty2.",
  "fpext": "The ‘fpext’ extends a floating-point value to a larger floating-point value.",
  "fptoui": "The ‘fptoui’ instruction converts its floating-point operand into the nearest (rounding towards zero) unsigned integer value. If the value cannot fit in ty2, the result is a poison value.",
  "fptosi": "The ‘fptosi’ instruction converts its floating-point operand into the nearest (rounding towards zero) signed integer value. If the value cannot fit in ty2, the result is a poison value.",
  "uitofp": "The ‘uitofp’ instruction interprets its operand as an unsigned integer quantity and converts it to the corresponding floating-point value. If the value cannot be exactly represented, it is rounded using the default rounding mode. If the nneg flag is set, and the uitofp argument is negative, the result is a poison value.",
  "sitofp": "The ‘sitofp’ instruction interprets its operand as a signed integer quantity and converts it to the corresponding floating-point value. If the value cannot be exactly represented, it is rounded using the default rounding mode.",
  "ptrtoint": "The ‘ptrtoint’ instruction converts value to integer type ty2 by interpreting all the pointer representation bits as an integer (equivalent to a bitcast) and either truncating or zero extending that value to the size of the integer type. If value is smaller than ty2 then a zero extension is done. If value is larger than ty2 then a truncation is done. If they are the same size, then nothing is done (no-op cast) other than a type change. The ptrtoint always captures address and provenance of the pointer argument.",
  "ptrtoaddr": "The ‘ptrtoaddr’ instruction converts value t                                                                                                                                                                                                                                                                                                                                                                    o integer type ty2 by interpreting the lowest index-width pointer representation bits as an integer. If the address size and the pointer representation size are the same and value and ty2 are the same size, then nothing is done (no-op cast) other than a type change. The ptrtoaddr instruction always captures the address but not the provenance of the pointer argument.",
  "inttoptr": "The ‘inttoptr’ instruction converts value to type ty2 by applying either a zero extension or a truncation depending on the size of the integer value. If value is larger than the size of a pointer then a truncation is done. If value is smaller than the size of a pointer then a zero extension is done. If they are the same size, nothing is done (no-op cast). The behavior is equivalent to a bitcast, however, the resulting value is not guaranteed to be dereferenceable (e.g. if the result type is a non-integral pointers).",
  "bitcast": "The ‘bitcast’ instruction converts value to type ty2. It is always a no-op cast because no bits change with this conversion. The conversion is done as if the value had been stored to memory and read back as type ty2. Pointer (or vector of pointers) types may only be converted to other pointer (or vector of pointers) types with the same address space through this instruction. To convert pointers to other types, use the inttoptr or ptrtoint instructions first. There is a caveat for bitcasts involving vector types in relation to endianness. For example bitcast <2 x i8> <value> to i16 puts element zero of the vector in the least significant bits of the i16 for little-endian while element zero ends up in the most significant bits for big-endian.",
  "addrspacecast": "The ‘addrspacecast’ instruction converts ptrval from pty in address space n to type pty2 in address space m.",
  "icmp": "The ‘icmp’ instruction returns a boolean value or a vector of boolean values based on comparison of its two integer, integer vector, pointer, or pointer vector operands.",
  "fcmp": "The ‘fcmp’ instruction returns a boolean value or vector of boolean values based on comparison of its operands. If the operands are floating-point scalars, then the result type is a boolean (i1). If the operands are floating-point vectors, then the result type is a vector of boolean with the same number of elements as the operands being compared.",
  "phi": "At runtime, the ‘phi’ instruction logically takes on the value specified by the pair corresponding to the predecessor basic block that executed just prior to the current block.",
  "select": "If the condition is an i1 and it evaluates to 1, the instruction returns the first value argument; otherwise, it returns the second value argument. If the condition is a vector of i1, then the value arguments must be vectors of the same size, and the selection is done element by element. If the condition is an i1 and the value arguments are vectors of the same size, then an entire vector is selected.",
  "freeze": "If the argument is undef or poison, ‘freeze’ returns an arbitrary, but fixed, value of type ‘ty’. Otherwise, this instruction is a no-op and returns the input argument. All uses of a value returned by the same ‘freeze’ instruction are guaranteed to always observe the same value, while different ‘freeze’ instructions may yield different values. While undef and poison pointers can be frozen, the result is a non-dereferenceable pointer. See the Pointer Aliasing Rules section for more information. If an aggregate value or vector is frozen, the operand is frozen element-wise. The padding of an aggregate isn’t considered, since it isn’t visible without storing it into memory and loading it with a different type.",
  "call": "The ‘call’ instruction is used to cause control flow to transfer to a specified function, with its incoming arguments bound to the specified values. Upon a ‘ret’ instruction in the called function, control flow continues with the instruction after the function call, and the return value of the function is bound to the result argument. If the callee refers to an intrinsic function, the signature of the call must match the signature of the callee. Otherwise, if the signature of the call does not match the signature of the called function, the behavior is target-specific. For a significant mismatch, this likely results in undefined behavior. LLVM interprocedural optimizations generally only optimize calls where the signature of the caller matches the signature of the callee. Note that it is possible for the signatures to mismatch even if a call appears to be a “direct” call, like call void @f().",
  "va_arg": "The ‘va_arg’ instruction loads an argument of the specified type from the specified va_list and causes the va_list to point to the next argument. For more information, see the variable argument handling Intrinsic Functions. It is legal for this instruction to be called in a function which does not take a variable number of arguments, for example, the vfprintf function. va_arg is an LLVM instruction instead of an intrinsic function because it takes a type as an argument.",
  "landingpad": "The ‘landingpad’ instruction is used by LLVM’s exception handling system to specify that a basic block is a landing pad — one where the exception lands, and corresponds to the code found in the catch portion of a try/catch sequence. It defines values supplied by the personality function upon re-entry to the function. The resultval has the type resultty.",
  "catchpad": "The ‘catchpad’ instruction is used by LLVM’s exception handling system to specify that a basic block begins a catch handler — one where a personality routine attempts to transfer control to catch an exception.",
  "cleanuppad": "The ‘cleanuppad’ instruction is used by LLVM’s exception handling system to specify that a basic block is a cleanup block — one where a personality routine attempts to transfer control to run cleanup actions. The args correspond to whatever additional information the personality function requires to execute the cleanup. The resultval has the type token and is used to match the cleanuppad to corresponding cleanuprets. The parent argument is the token of the funclet that contains the cleanuppad instruction. If the cleanuppad is not inside a funclet, this operand may be the token none."
}